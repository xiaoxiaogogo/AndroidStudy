apply plugin: 'com.android.application'

apply from: 'demo.gradle'
apply from: 'demo2.gradle'

apply from: 'demo3.gradle'

apply plugin: 'hello'

//hello {
//    // 直接对 对象 的属性进行赋值
////    sayHi = 'haha, I am in app'
//    sayHi 'haha, I am in app'
//}
//
//multiDomain {
//    custom{
//        sourceDir = file('src/docs/cus')
//    }
//    second {
//    }
//}


android {
    compileSdkVersion 25
    buildToolsVersion "25.0.2"
    defaultConfig {
        applicationId "com.gavin.androidstudy"  // 应用的唯一标识，更改，则代表另外的一个应用
        minSdkVersion 14
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }

    dexOptions{
        preDexLibraries true // 不知道从哪个版本开始默认为true， 2.3.0默认是true, 提前将library打包成dex，然后需要时合并即可，因为library不会改变，因此会提升增量更新的性能；
        // 但是会使clean之后打包变慢，因此如果在服务器上，可以将此选项关闭
        incremental true // 2.1.0 默认是true， 支持增量更新
        jumboMode true // 2.1.0 默认是true，因为编译有最大字符串数量的限制，这个是为了扩充字符串数量
        javaMaxHeapSize '4g' // 2.3.0默认是1024M， dx编译过程可以申请的最大内存
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:25.3.1'
    testCompile 'junit:junit:4.12'
    compile 'org.codehaus.groovy:groovy:2.4.0:grooid'
}

def demo(){
    // 1. groovy中没有基本数据类型，它任务任何事物都是对象；它会将基本数据类型包装成其对应的包装类型

    // 2. groovy中的容器类
    // List , 其底层对应java的List接口，一般用ArrayList作为实现类
    def emptyList = [] // 创建一个空的list
    def list = ['hello', 100, 'word'] // List中可以存储多种数据类型
    list[2] = 200 // 修改
    list << 'fuck' // 新增
    println list[2]
    println list.size()

    for (def i=0; i< list.size(); i++){
        println list[i]
    }

    // each 遍历 list
    list.each {
        println it
    }

    // for in 遍历
    for (v in list){
        println v
    }

    // Map : 底层对应java的LinkedHashMap
    // 注意： key必须用字符串
    def emptyMap = [:] // 创建空的map
    def map = ['key1': 100, 'key2':'hello']
    // 通过key获取value
    def val1 = map.key1
    def val2 = map['key2']
    // 添加新元素
    map['key'] = true
    // each 遍历map集合
    map.each {key, val ->
        println 'map each : key : '+key+"; value : ${val}"
    }

    map.each {
        println "map each(no params) : key: ${it.key}, value : ${it.value}" // 注意： ${}只能在 双引号中才能使用
    }


    // Range : Groovy对List的一种拓展
    def range1 = 1..5 // 包含了 1，2，3，4，5
    def range2 = 1..<5 // 包含 1，2，3，4(不包括5)
    println range1.from
    println range1.to
    range1.each {
        println "Range iterator : ${it}"
    }


    // Groovy 特性：
    // 1.会为对象的成员变量，自动增加getter和setter；所以我们查看api的时候，往往都会查到其成员变量对应get和set方法，我们 对象.成员变量，就是调用它的getter方法
    // 2. 默认访问权限是public


}

/**
 * 文件操作， 不用处理流的关闭操作
 */
def fileDemo(){
    def file = new File('app/a.txt') // 当前目录是 当前项目的根目录
    // 逐行读取
    file.eachLine {line, lineNo ->
        println "${lineNo} ${line}"
    }

    // 一次性获取
    byte[] bytes = file.getBytes()

    // 以流的方式读取 (一次性获取);;  好处： 无需处理流的关闭操作
    file.withInputStream {is ->
        println is.getText()
    }

    def writeFile = new File('app/b.txt')
    // write() 覆盖内容；；   append() 向尾部追加内容
    writeFile.withOutputStream { os ->
        file.withInputStream { is ->
            os << is  // 重载了<< 符号，将输入流的数据传递给输出流
        }
    }
}


def printItem (item){
    println item
}

// 特殊符号
def syntxDemo(){
    def list = ['h', 'hello', 'jjj']

    println list?.size()  // ?. 相当于 判断list不为null，才执行size()方法， 否则直接返回null

    println list*.size()  // *. 相当于 用在集合对象里面，对里面每一个元素执行 size()方法，然后将返回值组成新的 list 返回

    // .& 相当于 将一个对象的 方法 转变成 closure 然后传递
    list.each(this.&printItem)

    // .@ 相当于 直接获取一个 对象中的 变量；； 注意 .变量名 调用的是此变量的 gettter方法

    def person = new Person(name : '小明')
    println person.name // 调用name的 getter方法
    println person.@name


    // ?: 相当于 java中三目运算符， 但是判断条件是前面的内容
    println person.@age ?: 'age is null'
}


def rangeDemo(){
    def rang = 1..<100 // 1~100， 不包括100
    println rang.from
    println rang[0]
    println rang.to
}


task myTest <<{
    demo()
//    fileDemo()

//    rangeDemo()

}


class Person{
    String name
    String age
    def getName(){ // name变量的 getter方法
        println 'name getter will be triggered'
        name
    }
}
