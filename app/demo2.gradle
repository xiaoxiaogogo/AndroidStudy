// 一。 gradle 基本命令

task compile << {
    println "compile source"
}

task compileTest(dependsOn: compile) << {
    println "test compile case"
    throw new RuntimeException("test exception!!")
}

task demoTest(dependsOn: [compile, compileTest]) << {
    println "test case"
}

task dist(dependsOn: [compile, demoTest]) << {
    println "building the distribution"
}

// gradle dist test : compile -> compileTest -> demoTest -> dist

//排除某个任务： -x (会将移除的任务依赖的子任务也移除掉，前提是这个子任务没有被要执行的任务依赖); 例如：gradle dist -x test : compile -> dist

//简化task名调用： gradle di(dist)  ；驼峰取首字母即可 gradle dT(demoTest)

// settings.gradle 指定了项目包含的目录； 因此gradle 默认执行的是 当前目录下的build.gradle文件(build.gradle, settings.gradle) ；； 当前可以使用-b 参数改变其目录，此时settings.gradle将不起作用
// 例子如下：./gradlew -b app/gradleTest/demo.gradle(指定gradle脚本) hello(task)

// gradle projects (查看当前工程目录 所有的项目)

// gradle help --task task名 (查看指定task的详细信息)

// --profile ： 生成构建日志到 build/reports/profile下面

// 二、编写gradle脚本
// 构建脚本没有找到的方法，都会委托给 project(也就是调用project上的)
// 构建脚本没有找到的属性，都会委托给 project
//println name // app
//println project.name // app

// 声明变量： 两种： def声明局部变量； gradle的额外属性
// 额外属性： ext定义， 包括但是不限于 project、 task 、 sourceSets； 例子如下
ext {
    extName = 'lufei'
}

/*sourceSets.all {  // all 是一个函数， 参数是一个闭包
    ext.purpose = null
}

sourceSets {
    main {
        purpose = 'main'
    }
    test {
        purpose = 'test'
    }
    plugin {
        purpose = 'main'
    }
}*/
task printExtProperties << {
    println project.extName
    sourceSets.matching { it.purpose == 'main' }.each { println it.name }
}


// 如果方法的最后一个参数是一个closure的话， 可以将 closure 方法方法调用的后面，也就是()的后面，例如：
// repositories() { println "in a closure" }  等价于  repositories({ println "in a closure" })




// project 可以访问到 gradle.properties里面的属性。 用户主目录下的属性文件 比 项目目录的属性文件 更优先被访问到
// 在gradle.properties中的systemProp. 设置系统属性， 只有根项目下的属性文件才能有作用
// 通过 project.hasProperty('propertyName') 检查是否设置了此项目属性



// apply from: '脚本路径' 使用外部脚本构建




/**
 * 闭包详解：
 */

class Person {
    String name
    int age

    def printPerson() {
        println "name is ${name}, age is ${age}"
    }
}

def person(Closure<Person> closure) {
    Person p = new Person()
    // 定义闭包中 执行对象
    println closure.getResolveStrategy() // 默认 OWNER_FIRST
    closure.delegate = p
    closure.setResolveStrategy(Closure.DELEGATE_FIRST)
    closure()
}

def printPerson() {
    println '当前构建上下文 print person'
}

task configClosure << {
    println 'execute config closure'
    person {
        name = 'xiaoming'
        age = 20
        printPerson()
    }
}

def x = 5
def y =15


// 闭包文档  ：  http://docs.groovy-lang.org/2.4.10/html/api/groovy/lang/Closure.html

class Test {

    def x = 30
    def y = 40

    def run() {
        // 默认 OWNER_FIRST
       /* def data = [x: 10, y: 20]
        // 默认 owner_first : 也就是closure 被谁拥有，也就是当前对象实例
        def cl = {
            y = x + y
        }
        cl.delegate = data
        cl()
        println x == 30
        println y == 70
        println data == [x: 10, y: 20]*/

        // OWNER_ONLY : 这种模式就是，即使你设置了delegate也没有用， 如果当前OWNER没有那么就会报错；并不会去delegate里面去寻找
        // 下面案例： 如果Test没有 z, 就会报错
        /*def data = [ x: 10, y: 20, z: 30 ]
        def cl = { y = x + y + z }
        cl.delegate = data
        cl.resolveStrategy = Closure.OWNER_ONLY
        cl()
        println x
        println y
        println data*/


        // DELEGATE_FIRST : 首先从 赋值的 委托里面去寻找
       /* def data = [ x: 10, y: 20 ]
        def cl = { y = x + y }
        cl.delegate = data
        cl.resolveStrategy = Closure.DELEGATE_FIRST
        cl()
        assert x == 30
        assert y == 40
        assert data == [x:10, y:30]*/

        //TO_SELF : 从闭包里面去寻找，没找到就会报错； 因为closure最终编译成class也是一个class，
        // 下面报错：No such property: x for class: Test$_run_closure1
        def data = [ x: 10, y: 20, z: 30 ]
        def cl = { y = x + y }
        cl.delegate = data
        cl.resolveStrategy = Closure.TO_SELF
        println x
        println y
        println data
    }
}



task testClosure << {
    new Test().run()
    println y
}



/*
    三、任务详解
 */


// 定义的task， 是project的一个成员， 可以通过project直接获取，例如
// project.testClosure.name

// 也可以通过 tasks获取，tasks是project的成员
//tasks.testClosure.name
//tasks["testClosure"].name


// 配置任务， 也就是使用闭包，声明任务的执行内容； 还有type，也就是支持对应的功能，比如Copy，如下
task initConfig(type: Copy) << {
    from('src/main/config') {
        include '**/*.properties'
        include '**/*.xml'
    }
    from('src/main/config') {
        exclude '**/*.properties', '**/*.xml'
    }
    from('src/main/languages') {
        rename 'EN_US_(.*)', '$1'
    }
    into 'build/target/config'
    exclude '**/*.bak'

    includeEmptyDirs = false
}

// 任务排序
// 两种排序方式 mustRunAfter   shouldRunAfter
testClosure.mustRunAfter configClosure


// 重写 覆盖任务
task testClosure(overwrite: true) << {
    println "overwrite testClosure task"
}


// 跳过任务
// 1. 使用断言， onlyIf  : 当满足条件才执行task
testClosure.onlyIf {
    project.hasProperty("skipTest")
}

// 抛出 StopExecutionException 异常，终止当前task的执行
task stopExceptionTask <<{
    println 'StopExecutionException 中断执行结果'
}
stopExceptionTask.doFirst {
    throw new StopExecutionException()
}


// task的 enabled 为 false， 也会跳过执行当前task
testClosure.enabled = false


// task 的 up-todate （当前任务的执行结果是最新内容，无需继续执行）
// 只有在于输出的task，才会进行判断，因为需要对输出结果进行校验，是否是没有发生改变

task inputOutput << {
    ext.srcFile = file('a.xml')
    ext.destDir = new File(buildDir, 'generated')
    def cFile = file('c.txt')
    // inputs.file srcFile  // 设置输入的文件
//    ouputs.dir destDir  // 设置输出的目录   如果这个目录下的文件没有发生改变，那么当期那task就是 up-to-date
    outputs.upToDateWhen {
        !cFile.exists()
    }
}

/**
 *  四、file 操作
 */


//1. project.file() 直接获取文件，可以通过相对路径、绝对路径、file对象获取，同java


//2. 获取文件集合 project.files() 返回的是 FileCollection对象
task testFiles() << {
    FileCollection collection = files('a.txt', new File('b.txt'), ['CMakeLists.txt', 'demo.gradle'])
    collection.each { file ->
        println file.absolutePath
    }
    // FileCollection 转换成其他集合
    Set set = collection.files
    Set set2 = collection as Set;
    List list = collection as List
    String path = collection.asPath  // 将所有文件的绝对路径 用 : 连接
    println path
//    println collection.singleFile  // 报错， 因为有四个文件
//    println (collection as File)   // 报错， 同上

    // 通过 加号 和 减号  直接操作集合
    def union = collection + files("test/a.txt")
    def differernt = union - files("a.txt")

    differernt.each { file ->
        println file.path
    }

}


//3.FileTree 文件树， 继承自 FileCollection， 用于表示一个目录树或ZIP文件内容。 source sets 继承FileCollection接口； 可以使用project.fileTree()获取FileTree实例
task fileTreeDemo << {
    FileTree tree = fileTree(dir: 'src/main')
    // 对目录中的文件进行筛选
        tree.include '**/*.java'
        tree.exclude '**/Abstract*'

    // fileTree()增加第二个参数, 使用闭包的方式添加筛选条件
        tree = fileTree(dir: 'src/main', {
            include '**/*.java'
        })

        tree = fileTree(dir: 'src', includes: '**/*.java')

    //遍历一个tree
        tree.each {File file ->
            println file.absolutePath
        }

    // filter 筛选
        FileTree filterTree = tree.matching {
            include '**/*.java'
        }

    // 也可以通过直接 加减 来处理FileTree


    // zipTree() 处理 .zip文件；  tarTree() 处理 .tar文件；； 获取到的FileTree之后，使用和原来一样， 可以通过此FileTree来增加归档文件的大小，例如：往里面添加文件

    // 文件的压缩
    //resources.gzip('src/a.txt')


    //文件的copy， 不能进行增量操作，比如上面
    task anotherCopyTask(type: Copy) {
        // Copy everything under src/main/webapp
        from 'src/main/webapp'
        // Copy a single file
        from 'src/staging/index.html'
        // Copy the output of a task
        from copyTask
        // Copy the output of a task using Task outputs explicitly.
        from copyTaskWithPatterns.outputs
        // Copy the contents of a Zip file
        from zipTree('src/main/assets.zip')
        // Determine the destination directory later

        // 增加筛选条件
        include '**/*.java'
        include '**/*.html'
        exclude { details ->
            details.file.name.endsWith('.html') && details.file.text.contains('staging')
        }
        into { getDestDir() }
    }
    // 第二种方式 ： project.copy{} 使用方式同上面


    // 创建归档文件 zip文件
    // 类似copy 任务，  要归档的文件可以进行筛选； 同时还可以对归档文件进行重命名； 具体详解 参考文档
    task myZip(type: Zip) {
        from 'somedir'
    }

    println myZip.archiveName
    println relativePath(myZip.destinationDir)
    println relativePath(myZip.archivePath)

}











